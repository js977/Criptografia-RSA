
\chapter{Criptografia RSA}
\label{sec:criptografiaRSA}

A implementação do algoritmo RSA é bastante utilizado para assegurar a segurança das comunicações digitais. Este algoritmo baseia-se em um par de chaves: uma chave pública utilizada para encriptar os dados e uma chave privada correspondente para desencriptar.

Na encriptação RSA, o remetente utiliza a chave pública do destinatário para transformar os dados originais em um formato encriptado. O resultado é um texto encriptado, que pode ser enviado com segurança.

Por outro lado, na desencriptação RSA, o destinatário utiliza sua chave privada correspondente para reverter o processo anterior. Com isso, o destinatário obtém novamente os dados originais, protegendo a confidencialidade da informação.

A segurança do algoritmo RSA baseia-se na dificuldade de fatorizar números primos de grande dimensão, pois as chaves pública e privada são geradas a partir desses números.\footnote{Size considerations for public and private keys, \url{https://www.ibm.com/docs/en/zos/2.3.0?topic=certificates-size-considerations-public-private-keys}}

Portanto, uma implementação bem-sucedida da cifra RSA requer desenvolver corretamente algoritmos matemáticos, incluindo geração de chaves, encriptação e  desencriptação garantindo assim a segurança das comunicações digitais. Também são criadas funções secundárias que auxiliam as funções mencionadas anteriormente, nomeadamente de conversão e de operação de congruência.

\section{Cifra RSA---Geração das Chaves}
\label{ec:cifraRSAGeracaoChaves}
Para empregar o algoritmo RSA, em primeiro lugar,  é preciso gerar chaves pública e privada para cifrar ou decifrar a mensagem, respetivamente.  

Seja $(e,n)$ a chave pública e $(d,n)$ a chave privada, onde \emph{e} tal que $1<e<\phi(n)$ é primo relativo com $\phi(n)$ e \emph{d} é o inverso multiplicativo de \emph{e} módulo $\varphi(n)$, ou seja $de \equiv 1(mod \phi(n))$.

\begin{itemize}
    \item[$\hookrightarrow$] \emph{p}, \emph{q}, dois números primos de grande dimensão;
    \item[$\hookleftarrow$] \emph{(e,n)} e \emph{(d,n)}, as chaves: pública e privada
\end{itemize}
\begin{lstlisting}[frame=single,mathescape=true,caption={Cifra RSA ---Especificação de \texttt{GerarChavePrivada}},captionpos=b,label={lst:gerarChavePrivada},basicstyle=\footnotesize]
int* gerarChavePrivada(int , int ,int );
\end{lstlisting}
\begin{lstlisting}[frame=single,mathescape=true,caption={Gerar chave privada},captionpos=b,label={lst:Gerar chave privada},basicstyle=\footnotesize]
int* gerarChavePrivada(int p, int q,int e){
// Aloca dinamicamente um array de 2 inteiros
    int* chaveP = (int*)malloc(2 * sizeof(int)); 

if (chaveP == NULL) {
    // Se a alocação falhar
    return NULL;
}
chaveP[0]=inversoMultiplicativo((p-1)*(q-1),e);
chaveP[1]=p*q;
return chaveP;
}
\end{lstlisting}
\begin{lstlisting}[frame=single,mathescape=true,caption={Cifra RSA ---Especificação de \texttt{GerarChavePública}},captionpos=b,label={lst:gerarChavePublica},basicstyle=\footnotesize]
int* gerarChavePublica(int ,int );
\end{lstlisting}
\begin{lstlisting}[frame=single,mathescape=true,caption={Gerar chave privada},captionpos=b,label={lst:Gerar chave privada},basicstyle=\footnotesize]
int* gerarChavePublica(int q,int p){
// Aloca dinamicamente um array de 2 inteiros
int* chaveP = (int*)malloc(2 * sizeof(int)); 
int omega_n=(p-1)*(q-1);
if (chaveP == NULL) {
    // Se a alocação falhar
    return NULL;}
//chaveP[1]=(p-1)*(q-1);
chaveP[1]=p*q;
//calcular e -->pequeno para melhorar a encriptação
for(int i=2;i<omega_n;i++){
    
    if(ePrimo(i,omega_n)){
        chaveP[0]=i;
        break;}}
    return chaveP;}
\end{lstlisting}


\section{Cifra RSA---Encriptação}
\label{ec:cifraRSAencriptacao}

Para a encriptação RSA tem-se:

\begin{itemize}
    \item[$\hookrightarrow$] mensagem a cifrar, a chave pública, $(e,n)$;
    \item[] encriptar número a número através da função de encriptação;
    \item [$\hookleftarrow$] texto cifrado.
\end{itemize}

\begin{lstlisting}[frame=single,mathescape=true,caption={Cifra RSA ---Especificação de \texttt{CifraEncriptar}},captionpos=b,label={lst:rsaCifraEncriptar},basicstyle=\footnotesize]
int cifraEncriptar(int,int,int);
\end{lstlisting}

\begin{lstlisting}[frame=single,mathescape=true,caption={Encriptação RSA},captionpos=b,label={lst:EncriptacaoRSA},basicstyle=\footnotesize]
void encriptar(int e,int n,fstream& fin,fstream& fout){
int i=0,aux;
string linha;
string nomeMsg;
while (getline(fin, linha)) {//Obter as linhas do ficheiros
      while(linha[i]!='\0'){
        //converter as letras da linha em numeros
        aux=conversaoDS_LN(linha[i]);
        aux=cifraEncriptar(e,n,aux);//Aplicação de encriptação
        i+=1;
        if(aux > n){
            aux=aux%(n);}
        fout <<aux<<" ";}
    fout << endl;
    i=0;}
fout.close();//fechar ambos os ficheiros
fin.close();}

\end{lstlisting}

\section{Cifra RSA---Desencriptação}
\label{ec:cifraRSAdesencriptacao}


Ao receber um texto cifrado, o destinatário precisa seguir um conjunto de passos para obter a mensagem original. O processo de desencriptação inicia-se com a mensagem a ser decifrada, que foi previamente cifrada usando a chave pública correspondente. A chave de desencriptação, mantida em segredo pelo destinatário, é indispensável para este procedimento.

Portanto a geração da chave de desencriptação é um passo essencial, pois é por meio dela que a informação codificada pode ser revertida ao seu estado original. Esta chave, em conjunto com a função de desencriptação associada ao algoritmo RSA, permite o processo de decifração do texto original.

Logo ao desencriptar número a número através da função de desencriptação utilizando a chave privada correspondente, o destinatário é capaz de recuperar o texto original, assegurando a privacidade e a segurança das informações transmitidas. 

Portanto para desencriptação RSA tem-se:
\begin{itemize}
    \item[$\hookrightarrow$] mensagem a decifrar;
    \item[] desencriptar número a número através da função de desencriptação;
    \item [$\hookleftarrow$] texto original.
\end{itemize}

\begin{lstlisting}[frame=single,mathescape=true,caption={Cifra RSA ---Especificação de \texttt{CifraDesencriptar}},captionpos=b,label={lst:rsacifraDesencriptar},basicstyle=\footnotesize]
void desencriptar(int,int ,fstream& ,fstream& );
\end{lstlisting}

\begin{lstlisting}[frame=single,mathescape=true,caption={Gerar chave privada},captionpos=b,label={lst:Gerar chave privada},basicstyle=\footnotesize]
void desencriptar(int p,int q,fstream& fin,fstream& fout){
int i=0,aux,d;
int* chaveP = (int*)malloc(2 * sizeof(int)); // Aloca dinamicamente array
if (chaveP == NULL){
    // Se a alocação falhar
    cout<<"Alocação falhou...";}
chaveP=gerarChavePublica(p,q);
d=inversoMultiplicativo(chaveP[1],chaveP[0]);
string nomeMsg;
string linha;
    while (getline(fin, linha)) {//Obter as linhas do ficheiros
          istringstream linhaAux(linha);
          while(linhaAux >> aux){
          //Aplicação de encriptação
          aux=cifraEncriptar(d,p*q,aux);
            i+=1;
            if(aux > (p*q)){
                aux=aux%(p*q);}
            fout << conversaoDS_NL(aux);}
        fout << endl;
        i=0;}
    //fechar ambos os ficheiros
    fin.close();fout.close();}
\end{lstlisting}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End:
