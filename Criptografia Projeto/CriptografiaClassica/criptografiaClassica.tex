\chapter{Criptografia Clássica}
\label{sec:CriptografiaClassica}


Relativamente à criptografia de deslocamento (cifras pré-computacionais), cifras simples 
caracterizadas pelo deslocamento que estabelecem nas letras do alfabeto, vão ser
implementadas as cifras de deslocamento simples e linear. Para isto,
primeiramente, é realizada uma pré-codificação aonde os letras do
nosso alfabeto irão ser convertidas em números. Em seguida, executados
códigos elaborados em \emph{C++ }com vista a implementar a encriptação,
desencriptação e o quebrar da cifra.


$\textbf{Pré-codificação}$

Vamos supor, por simplificação, que a mensagem original contém apenas letras minúsculas e espaços entre palavras. Esta primeira etapa vamos designar por $\textbf{pré-codificação}$. 

Na codificação as letras vão ser convertidas em números de acordo com a tabela seguinte (ver Tabela~\ref{tbl:TabelaConversao}):

\begin{table}[htbp!]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
a & b & c & d & e & f & g & h & i & j & k & l & m \\
 \hline
 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 \\
 \hline\hline
n & o & p & q & r & s & t & u & v & w & x & y & z \\
 \hline
 13 & 14 & 15 & 16 & 17 & 18 & 19 & 20 & 21 & 22 & 23 & 24 & 25 \\
 \hline
 \end{tabular}
 \caption{Tabela de Conversão}
 \label{tbl:TabelaConversao}
\end{table}

Por exemplo, a frase ``criptografia''. Inicialmente vai ser codificada no conjunto de algarismos:
\begin{center}
2~17~8~15~19~14~6~17~0~5~8~0
\end{center}

Ao aplicarmos a cifra deslocamento linear, com chave 5, obtém-se:
\begin{center}
  7~22~13~20~24~19~11~23~5~10~15~5
\end{center}

Finalmente, convertendo novamente para letras vamos obter
\begin{center}
hwnuytlxfkpf
\end{center} 

\section{Cifra de Deslocamento Simples}
\label{sec:CifraDeslocamentoSimples}

A abordagem da cifra de deslocamento simples é uma cifra clássica, onde a segurança de uma mensagem é assegurada através da substituição de cada letra por outra situada a um número fixo de posições à ``frente'' no alfabeto. Este método, também conhecido por ser um caso particular do deslocamento linear, apresenta uma técnica direta e importante na história da criptografia, baseada na ideia de variações sistemática das letras para assegurar a confidencialidade das informações. No âmbito prático, exploramos não apenas o processo de encriptação e desencriptação, mas também a criptoanálise, revelando como a busca exaustiva no espaço das chaves permite a quebra da cifra e a recuperação do texto original. Este estudo detalhado revela os princípios e vulnerabilidades desse método clássico, ressaltando a importância de procedimentos mais robustos na proteção de dados sensíveis nos tempos modernos~\cite[Cap.4]{Songo2024}.

Para desenvolver a cifra de deslocamento em \emph{C++}, é necessário criar as funções de encriptação, desencriptação e quebra-cifra. Além disso, algumas funções auxiliares, como a conversão de letras para números e de números para letras, devem ser criadas. Logo, tem-se:


%\begin{lstlisting}[frame=single,mathescape=true,caption={Deslocamento simples},captionpos=b,label={lst:Deslocamento simples},basicstyle=\footnotesize]
%#ifndef IGD
%#define IGD
%using namespace std;
%int conversaoDS_LN(char );//converte letra para numero
%int cifraEncriptar(int,int ,int );//Encripta a letra
%int cifraDesencriptar(int ,int,int);//Desencripta a letra
%void encriptar(int,fstream&,fstream&);//encripta o texto
%char conversaoDS_NL(int );//converte número para letra
%void desencriptar(int ,fstream& ,fstream& );//desencripta o texto
%void quebraCif
%\end{lstlisting}

\subsection{Cifra de Deslocamento Simples---Encriptação}
\label{sec:CDSEncriptacao}

Para esta segunda etapa, precisamos, de conhecer, além do texto claro, o valor da chave (deslocamento) $0<k<|\cal A|$. Tem-se:

\begin{itemize}
    \item[$\hookrightarrow$] mensagem a cifrar, chave;
    \item[] encriptar número a número através da função de encriptação;
    \item[$\hookleftarrow$] texto cifrado.
\end{itemize}

\paragraph{Especificação:} {\ }

\begin{lstlisting}[frame=single,mathescape=true,caption={Cifra de Deslocamento Simples---Especificação de \texttt{cifraEncriptar}},captionpos=b,label={lst:DeslocamentoSimples},basicstyle=\footnotesize]
int cifraEncriptar(int,int ,int );//Encripta a letra
\end{lstlisting}
%\lstinputlisting[frame=single,mathescape=true,caption={Pilha de
%  Inteiros (especificação)},captionpos=t,label={lst:pilhaInth}]{Programas/pilhaInt.h}

\paragraph{Implementação:} {\ }

\begin{lstlisting}[frame=single,mathescape=true,caption={Encriptar},captionpos=b,label={lst:Encriptar},basicstyle=\footnotesize]
void encriptar(int k,fstream& fin,fstream& fout){//Encripta mensagens
    int i=0,aux;
    string linha;
    string nomeMsg;
        while (getline(fin, linha)) {//Obter as linhas do ficheiros
              while(linha[i]!='\0'){
                aux=conversaoDS_LN(linha[i]);//Letras --->numeros
                aux=cifraEncriptar(aux,k,26);//Aplicação de encriptação
                i+=1;
                if(aux >26){
                    aux=aux%26;}
                fout << conversaoDS_NL(aux);}
            fout << endl;
            i=0;}
        fout.close();//fechar ambos os ficheiros
        fin.close();}
\end{lstlisting}

Um exemplo de utilização desta cifra, vai-se encriptar o seguinte texto:
\begin{verbatim}
    a  criptografia classica
    deslocamento linear
    universidade de coimbra
\end{verbatim}
Para cifra de Julho César, $k=3$, vamos obter o seguinte texto cifrado
\begin{verbatim}
    dNfulswrjudildNfodvvlfdN
    ghvorfdphqwrNolqhdu
    xqlyhuvlgdghNghNfrlpeud
\end{verbatim}

Nota: 'N' corresponde a valores que estão fora do nosso alfabeto. Nesse caso, o espaço cujo valor é 26 com a codificação escolhida ficou de fora do nosso alfabeto, tendo-se optado por uma não encriptação nesses casos.

\subsection{Cifra de Deslocamento Simples---Desencriptação}
\label{sec:CifraDeslocamentoSimplesdesencriptação}
Na cifra de deslocamento simples, o valor de $k$ da chave de encriptação corresponde ao mesmo valor para a chave de desencriptação. Tem-se:

Desencriptação
\begin{itemize}
    \item[$\hookrightarrow$]  mensagem cifrada, chave;
    \item[] desencriptar número a número através da função de encriptação;
    \item[$\hookleftarrow$]  texto original.
\end{itemize}

\paragraph{Especificação:} {\ }

\begin{lstlisting}[frame=single,mathescape=true,caption={Cifra de Deslocamento Simples---Especificação de \texttt{cifraDesencriptar}},captionpos=b,label={lst:DeslocamentoSimplesDesencriptar},basicstyle=\footnotesize]
int cifraDesencriptar(int, int, int, int);//Desencripta a letra
\end{lstlisting}

\paragraph{Implementação:} {\ }
\begin{lstlisting}[frame=single,mathescape=true,caption={Desencriptar},captionpos=b,label={lst:Desencriptar},basicstyle=\footnotesize]
void desencriptar(int k,fstream& fin,fstream& fout){//desencripta mensagens
int i=0,aux;
//string nomeMsg;
string linha;
    while (getline(fin, linha)){//Obter as linhas do ficheiro.txt
          while(linha[i]!='\0'){
            aux=linha[i];
            aux=conversaoDS_LN(linha[i]);
            aux=cifraDesencriptar(k,aux,26);
            while(aux<0){
                aux=aux+26;}
            i+=1;
            fout << conversaoDS_NL(aux);}
        fout << endl;
        i=0;}
    fout.close();
    fin.close();}
\end{lstlisting}
Continuando do passo anterior, para $k=3$, vamos obter o seguinte texto decifrado:
\begin{verbatim}
aNcriptografiaNclassicaN
deslocamentoNlinear
universidadeNdeNcoimbra
\end{verbatim}
Neste caso, 'N' que ficou fora do alfabeto corresponde ao espaço entre as palavras.

\subsection{Cifra de Deslocamento Simples---Quebrar a Cifra}
\label{sec:CifraDeslocamentoSimplesQuebraracifra}
Relativamente a criptoanálise, para esta cifra efetuou-se um ataque
por procura exaustiva no espaço das chaves, ou seja, verificaram-se
todas as possíveis chaves no espaço das chaves.


\begin{itemize}
    \item[$\hookrightarrow$] mensagem a cifrada;
    \item[] desencriptar número a número através da função de ``quebra cifra'';
    \item[$\hookleftarrow$] texto original.
\end{itemize}


\paragraph{Especificação:} {\ }

\begin{lstlisting}[frame=single,mathescape=true,caption={Cifra de Deslocamento Simples---Especificação de \texttt{cifraDesencriptar}},captionpos=b,label={lst:DeslocamentoSimplesDesencriptar},basicstyle=\footnotesize]
int cifraDesencriptar(int , int ,int,int);//Desencripta a letra
\end{lstlisting}

\paragraph{Implementação:} {\ }

\begin{lstlisting}[frame=single,mathescape=true,caption={Quebrar a cifra},captionpos=b,label={lst:Quebrar a cifra},basicstyle=\footnotesize]
void quebraCifra(string nome){
int aux = 0;
string nomeMsg;
string linha;
fstream fd;
for (int k = 1; k <= 26; k++) {
fstream fin(nome, std::ios::in | std::ios::binary);// abrir o ficheiro
if (!fin.is_open()) {
    cerr << "Impossível abrir o arquivo " << endl;
    return; // no caso de não conseguir abrir o ficheiro}
aux = aux + 1;
nomeMsg = "MensagemDecifrada" + to_string(aux) + ".txt";
fd.open(nomeMsg, std::ios::out);
if (!fd.is_open()) {
    cerr << "Impossível criar o arquivo " << nomeMsg << endl;
    return; 
}
desencriptar(k, fin, fd);
fd.close();
//fin.clear(); // Clear the stream state
fin.seekg(0); // apontar para o inicio
fin.close();}}
\end{lstlisting}
Portanto geraram-se $27$ ficheiros do tipo texto (.txt) dos quais apresentam-se, em seguida, os 4 primeiros resultados :
\begin{verbatim}
dqfulswrjudildqfodvvlfd
ghvorfdphqwrqolqhdu
xqlyhuvlgdghqghqfrlpeud
\end{verbatim}
\begin{verbatim}
cpetkrvqitchkcpencuukec
fgunqecogpvqpnkpgct
wpkxgtukfcfgpfgpeqkodtc
\end{verbatim}
\begin{verbatim}
bodsjquphsbgjbodmbttjdb
eftmpdbnfoupomjofbs
vojwfstjebefoefodpjncsb
\end{verbatim}
\begin{verbatim}
ancriptografianclassica
deslocamentonlinear
universidadendencoimbra
\end{verbatim}

Assim, através da análise dos textos anteriores, é evidente que o último deles, escrito em uma linguagem percetível, corresponde ao nosso texto original.

\medskip

Iremos de seguida repetir os procedimentos descritos, mas agora para o deslocamento
linear. Será fácil de ver que a cifra descrita acima é uma cifra de
deslocamento linear, para o caso particular em que o valor da componente multiplicativa da chave, $a$, é $1$.

\section{Cifra de Deslocamento Linear}
\label{sec:CifraDeslocamentoLinear}

Esse método, também conhecida como cifra afim, procede através de uma função matemática que move cada letra da mensagem original de acordo com uma chave de encriptação $(a,b)$. Este procedimento é fundamental para garantir a proteção das informações transmitidas, ao substituir as letras por outras correspondentes na mensagem cifrada.

O propósito deste estudo é explorar em detalhes os processos de encriptação e desencriptação nessa cifra. Além disso, será abordada a criptoanálise, um método aplicado para quebrar a cifra por meio de ataques de força bruta, testando todas as possíveis chaves no espaço das chaves.

Seguidamente, analisaremos os resultados de tentativas de quebra da cifra, identificando a abordagem bem-sucedida para recuperar a mensagem original. Essa análise minuciosa permite compreender a funcionalidade e a fragilidade desse método clássico de criptografia diante de ataques de força bruta e sua importância na segurança da informação.

Para implementar a cifra de deslocamento linear precisamos de criar, primeiramente, funções secundárias para calcular o inverso multiplicativo e conversão de letra para número e vice-versa para auxiliar as funções, nomeadamente, as cifras de encriptação e desencriptação, que por sua vez, completam as funções de encriptação, desencriptação e quebra-cifra.

\subsection{Cifra de Deslocamento Linear---Validação da Chave}
\label{sec:cdlValidacaoChave}
\textcolor{red}{Testar as modificações da validação}

Para utilizar as cifras de deslocamento linear, nomeadamente, as cifras de desencriptação e quebra cifra precisamos, previamente, validar a chave de encriptação. Para isso, tem-se que verificar se \emph{a} tem inverso multiplicativo modulo \emph{n}. 

\paragraph{Especificação:} {\ }

\begin{lstlisting}[frame=single,mathescape=true,caption={Cifra de Deslocamento Simples---Especificação de \texttt{cifraDesencriptar}},captionpos=b,label={lst:DeslocamentoSimplesDesencriptar},basicstyle=\footnotesize]
//Encontrar o inverso multiplicativo
int inversoMultiplicativo(int,int);
\end{lstlisting}

\begin{lstlisting}[frame=single,mathescape=true,caption={Validação da chave},captionpos=b,label={lst:validacaodaschaves},basicstyle=\footnotesize]
//calcula o inverso multiplicativo de b mod n
int inversoMultiplicativo(int n,int b){
int  n0=n;
int t0=0;
int t=1;
int q=n0/b;
int r=n0-q*b;
int temp;
while(r > 0){
    temp=t0 -q*t;
    if (temp >=0)
        temp=temp%n;
    else
        temp=n-((-temp)%n);
//Atualização dos valores
t0=t;
t=temp;
n0=b;
b=r;
q=n0/b;
r=n0-q*b;
}
if(b==1)
    return t;
else
    return 0;}
\end{lstlisting}
 
\subsection{Cifra de Deslocamento Linear---Encriptação}
\label{sec:cdlEncriptacao}

Para encriptar a mensagem precisamos saber a chave de encriptação $(a,b)$. Tem-se:

Encriptação
\begin{itemize}
    \item[$\hookrightarrow$] mensagem a cifrar, $a$, $b$, os valores para a chave foram validados previamente;
    \item[] encriptar número a número através da função de encriptação;
    \item[$\hookleftarrow$] texto cifrado.
\end{itemize}

\paragraph{Especificação:} {\ }

\begin{lstlisting}[frame=single,mathescape=true,caption={Cifra de Deslocamento Linear---Especificação de \texttt{cifraEncriptar}},captionpos=b,label={lst:DeslocamentoLinearsEncriptar},basicstyle=\footnotesize]
//encripta o texto
void encriptar(int,int,fstream&,fstream&);
\end{lstlisting}
\begin{lstlisting}[frame=single,mathescape=true,caption={Encriptação},captionpos=b,label={lst:Encriptação},basicstyle=\footnotesize]
void encriptar(int a, int b,fstream& fin,fstream& fout){//Encripta mensagens
int i=0,aux;
string linha;
string nomeMsg;
while (getline(fin, linha)) {//Obter as linhas do ficheiros
  while(linha[i]!='\0'){aux=conversaoDS_LN(linha[i]);//Letras --> Numeros
    aux=cifraEncriptar(a,b,aux,26);//Aplicação de encriptação
    i+=1;
    if(aux >26){
        aux=aux%26;
    }
    fout << conversaoDS_NL(aux);
}
fout << endl;
i=0;}
fout.close();//fechar ambos os ficheiros
fin.close();}
\end{lstlisting}

Para a chave $(2,1)$ vamos cifrar o texto seguinte:
\begin{verbatim}
deslocamento linear
projeto e seminario
portugal e coimbra
\end{verbatim}
Obtém-se o seguinte texto cifrado
\begin{verbatim}
dNfulswrjudildNfodvvlfdN
ghvorfdphqwrNolqhdu
xqlyhuvlgdghNghNfrlpeud
\end{verbatim}

\subsection{Cifra de Deslocamento Linear---Desencriptação}
\label{sec:cdlDesencriptacao}

Desencriptação:
\begin{itemize}
    \item[$\hookrightarrow$] mensagem a cifrada, $a$, $b$;
    \item[] validar a chave
    \item[] encriptar número a número através da função de encriptação;
    \item[$\hookleftarrow$] texto original.
\end{itemize}

\paragraph{Especificação:} {\ }

\begin{lstlisting}[frame=single,mathescape=true,caption={Cifra de Deslocamento Linear---Especificação de \texttt{cifraDesencriptar}},captionpos=b,label={lst:DeslocamentoSimplesDesencriptar},basicstyle=\footnotesize]
//desencripta o texto
void desencriptar(int , int ,fstream& ,fstream& );
\end{lstlisting}

\begin{lstlisting}[frame=single,mathescape=true,caption={Desencriptação},captionpos=b,label={lst:Desencriptação},basicstyle=\footnotesize]
void desencriptar(int a, int b,fstream& fin,fstream& fout){//desencripta mensagens
int i=0,aux;
//string nomeMsg;
string linha;
    while (getline(fin, linha))  {//Obter as linhas do ficheiro.txt
        cout<<linha;
        cout<<endl<<"De mili ne";
          while(linha[i]!='\0'){
            aux=linha[i];
            aux=conversaoDS_LN(linha[i]);
        aux=cifraDesencriptar(a,b,aux,26);//cifra para desencriptar
            while(aux<0){
                aux=aux+26;}
            i+=1;
            fout << conversaoDS_NL(aux);}
        fout << endl;
        i=0;}
    fout.close();
    fin.close();}
\end{lstlisting}

Usando a mesma chave utilizada anteriormente para encriptar a mensagem obteve-se o seguinte texto cifrado:
\begin{verbatim}
aNcriptografiaNclassicaN
deslocamentoNlinear
universidadeNdeNcoimbra
\end{verbatim}

\subsection{Cifra de Deslocamento Linear---Quebrar a cifra}
\label{sec:cdlQuebrarCifra}

Relativamente a criptoanálise, uma vez que todas as cifras clássicas
são suscetíveis a ataque de força bruta, para esta cifra realizou-se
um ataque por procura exaustiva no espaço das chaves, ou seja, mais
uma vez  verificaram-se todas as possíveis chaves, neste caso, válidas no espaço das chave.


\begin{itemize}
    \item[$\hookrightarrow$] mensagem a cifrada;
    \item[]  desencriptar número a número através da função de "quebra cifra";
    \item[$\hookleftarrow$] texto original.
\end{itemize}

\paragraph{Especificação:} {\ }

\begin{lstlisting}[frame=single,mathescape=true,caption={Cifra de Deslocamento Linear---Especificação de \texttt{cifraQuebraCifra}},captionpos=b,label={lst:DeslocamentoLinearCifraQuebraCifra},basicstyle=\footnotesize]
//quebra a cifra gerando todas as combinações possíveis do texto cifrado
void quebraCifra(string );
\end{lstlisting}
\begin{lstlisting}[frame=single,mathescape=true,caption={Quebrar a cifra},captionpos=b,label={lst:Quebrar a cifra},basicstyle=\footnotesize]
void quebraCifra(string nome) {
int k = 0;
string nomeMsg;
string linha;
fstream fd;
for (int b = 0; b <= 26; b++) {
for (int a = 1; a <= 26; a++) {
    fstream fin(nome, std::ios::in | std::ios::binary); // abrir o ficheiro
    if (!fin.is_open()) {
        cerr << "Impossível abrir o arquivo " << endl;
        return; // no caso de não conseguir abrir o ficheiro}
    k = k + 1;
    nomeMsg = "MensagemDecifrada" + to_string(k) + ".txt";
    fd.open(nomeMsg, std::ios::out);
    if (!fd.is_open()) {
        cerr << "Impossível criar o arquivo " << nomeMsg << endl;
        return; }
    desencriptar(a, b, fin, fd);
    fd.close();
    //fin.clear(); // Clear the stream state
    fin.seekg(0); // Move file pointer to the beginning of the file
    fin.close();}}
// Close the file outside the loops}
\end{lstlisting}

\begin{verbatim}
dqfulswrjudildqfodvvlfd
ghvorfdphqwrqolqhdu
xqlyhuvlgdghqghqfrlpeud
\end{verbatim}
\begin{verbatim}
cpetkrvqitchkcpencuukec
fgunqecogpvqpnkpgct
wpkxgtukfcfgpfgpeqkodtc
\end{verbatim}
\begin{verbatim}
bodsjquphsbgjbodmbttjdb
eftmpdbnfoupomjofbs
vojwfstjebefoefodpjncsb
\end{verbatim}
\begin{verbatim}
ancriptografianclassica
deslocamentonlinear
universidadendencoimbra
\end{verbatim}

Portanto por interpretação dos textos acima, obviamente, que o último do textos dos 4 apresentados, que apresenta uma linguagem que permite ser compreendida, corresponde ao nosso texto original. 

Logo conseguimos quebrar a cifra, obtendo a chave de encriptação.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End:
